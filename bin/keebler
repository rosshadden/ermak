#!/usr/bin/env nu

source keymap.nu

# Map a key string into a QMK keycode.
def map [
	key: string # key alias to map
] {
	let parts = $key | parse "{fn}[{args}]" | get -i 0

	if $key in $keymap {
		$keymap | get $key
	} else if ($parts | is-not-empty) {
    $"(map $parts.fn)\((map $parts.args))"
	} else {
		$key
	}
}

# Process all layers and keys into QMK keycodes.
def "build codes" [ctx: record] {
	let layers = $ctx
	| get layers
	| each {|layer|
		let codes = get keys
		| compact
		| each {|key|
			into string
			| map $in
		}

		$layer | upsert codes $codes
	}
	$ctx | upsert layers $layers
}

# Generate QMK code for each layer.
def "build keymaps" [ctx: record] {
	let layers = $ctx
	| get layers
	| each {|layer|
		let keymap = $layer.codes
		| str join ", "
		| $"LAYOUT\(($in))"

		$layer
		| upsert id $"_($layer.name | str upcase)"
		| upsert keymap $keymap
	}
	$ctx | upsert layers $layers
}

# Generate QMK file.
def "build qmk" [ctx: record] {
	$ctx
	| to json
	| tera --stdin --template templates/keymap.c
}

def main [] {
	open data/keebler.nuon
	| build codes $in
	| build keymaps $in
	| build qmk $in
	| to json
}

# Generate QMK file.
def "main build" [] {
	open data/keebler.nuon
	| build codes $in
	| build keymaps $in
	| build qmk $in
}
