#!/usr/bin/env nu

const aliases = {
  0: KC_0
  1: KC_1
  2: KC_2
  3: KC_3
  4: KC_4
  5: KC_5
  6: KC_6
  7: KC_7
  8: KC_8
  9: KC_9
  A: KC_A
  B: KC_B
  C: KC_C
  D: KC_D
  E: KC_E
  F: KC_F
  G: KC_G
  H: KC_H
  I: KC_I
  J: KC_J
  K: KC_K
  L: KC_L
  M: KC_M
  N: KC_N
  O: KC_O
  P: KC_P
  Q: KC_Q
  R: KC_R
  S: KC_S
  T: KC_T
  U: KC_U
  V: KC_V
  W: KC_W
  X: KC_X
  Y: KC_Y
  Z: KC_Z

  F1: KC_F1
  F2: KC_F2
  F3: KC_F3
  F4: KC_F4
  F5: KC_F5
  F6: KC_F6
  F7: KC_F7
  F8: KC_F8
  F9: KC_F9
  F10: KC_F10
  F11: KC_F11
  F12: KC_F12

  kp*: KC_KP_ASTERISK
  kp+: KC_KP_PLUS
  kp,: KC_KP_COMMA
  kp-: KC_KP_MINUS
  kp.: KC_KP_DOT
  kp/: KC_KP_SLASH
  kp0: KC_KP_0
  kp1: KC_KP_1
  kp2: KC_KP_2
  kp3: KC_KP_3
  kp4: KC_KP_4
  kp5: KC_KP_5
  kp6: KC_KP_6
  kp7: KC_KP_7
  kp8: KC_KP_8
  kp9: KC_KP_9
  kp=: KC_KP_EQUAL
  kpE: KC_KP_ENTER

  "'": KC_QUOTE
  '!': KC_EXCLAIM
  '"': KC_DOUBLE_QUOTE
  '#': KC_HASH
  '|': KC_PIPE
  '$': KC_DOLLAR
  '%': KC_PERCENT
  '&': KC_AMPERSAND
  '(': KC_LEFT_PAREN
  ')': KC_RIGHT_PAREN
  '*': KC_ASTERISK
  '+': KC_PLUS
  ',': KC_COMMA
  '-': KC_MINUS
  '.': KC_DOT
  '/': KC_SLASH
  ';': KC_SEMICOLON
  '<': KC_LEFT_ANGLE_BRACKET
  '=': KC_EQUAL
  '>': KC_RIGHT_ANGLE_BRACKET
  '?': KC_QUESTION
  '@': KC_AT
  '[': KC_LEFT_BRACKET
  '\': KC_BACKSLASH
  ']': KC_RIGHT_BRACKET
  '^': KC_CIRCUMFLEX
  '`': KC_GRAVE
  '{': KC_LEFT_CURLY_BRACE
  '}': KC_RIGHT_CURLY_BRACE
  '~': KC_TILDE

  XXX: KC_NO
  ___: KC_TRANS
}

def transform [key: string] {
  let parts = $key | parse "{fn}[{args}]" | get -i 0

  if $key in $aliases {
    $aliases | get $key
  } else if ($parts | is-not-empty) {
    $"(transform $parts.fn)\((transform $parts.args))"
  } else {
    $key
  }
}

def main [] {
  open data/keebler.nuon
  | get layer_map
  | values
  | each {|layer|
    compact
    | each {|key|
      into string
      | transform $in
    }
  }
  | to nuon
}
